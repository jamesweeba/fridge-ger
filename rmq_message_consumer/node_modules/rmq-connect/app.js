const {
  connectToServer,
  createChannel,
  connectToExchange,
  processQueue
} = require("./mqservice");



/**
 * Connects to a rabbit mq server and exchange
 * @param {*} server 
 * @param {*} exchange 
 */
function connect(server, exchange, options = {
  exchangeType: 'topic',
  durable: true
}) {
  return new Promise((resolve, reject) => {
    var connection = {};
    connectToServer(server)
      .then(conn => {
        connection.conn = conn;
        return createChannel(conn)
      }).then(channel => {
        connection.channel = channel;
        connectToExchange(channel, exchange, options.exchangeType, {
          durable: options.durable
        });
      }).then(ok => {
        return resolve(connection);
      }).catch(err => {
        return reject(err);
      });
  })
}


/**
 * This closes connection to the rabbit mq server. Call connect() to get a new connection
 * @param {*} connection 
 */
function closeConnection(connection,delay=3000) {
  
  if (connection && connection.conn) {
    console.log("Connection will be closed after",delay,"ms");
    setTimeout(()=>{
      connection.conn.close();
    },delay)
  }

}



/**
 * Cosnsumes messages from a rabbitmq server
 * @param {*} server The rabiit mq server url eg. amqp://localhost
 * @param {*} queue The name of the queue to consume messages from
 * @param {*} callback (err,msg,done()). Call done after processing a message sucesfully
 * @param {Number} maxConsumeSize Max number of messages that can be consumed at a time.Default size is 10. Call done() in callback after processing messages to accept more
 */
function consumeMessages(server, queue, callback,maxConsumeSize=10) {
   var newServer = server+"?heartbeat=30"
   console.log("Connecting to server",newServer);
  
  connectToServer(newServer)
    .then(connection => {
      console.log("Connection to server successfull");
      //reconnect when connection error occurs
      connection.on("error",err=>{
        console.log("Error on connection, reconnecting  consumer");
        console.log(err);
        setTimeout(()=>{
          consumeMessages(server,queue,callback,maxConsumeSize);
        },1000)
        
      })

      return createChannel(connection);
    }).then(channel => {
      channel.checkQueue(queue,(err,ok)=>{
        if(err){
          return callback("Queue does not exist!");
        }
        
        processQueue(channel, queue, callback,maxConsumeSize);
      })
      
    }).catch(err => {
      callback(err, null, () => {
        console.log("Error processing queue completed");
      });
    });
}


/**
 * Publish a json payload to message queue
 * @param {*} connection Channel on which to publish. Call connect to get a 
 * @param {*} exchange The name of the exhange to publish to 
 * @param {*} key The routing key to be used eg. insyt.prod.signup
 * @param {*} payload The payload to be published eg {msisdn: 23432432424, name: "My name"}
 */
function publishJSON(connection, exchange, key, payload) {
  connection.channel.publish(exchange, key, Buffer.from(JSON.stringify(payload),{persistent : true}));
}



/**
 * Create a queue on the server. This will not create a new queue if queue already exists.
 * If a queue already exists then all parameters must match the existing queue, else it fails
 * @param {*} server The rabbitmq Server
 * @param {*} exchange The exchange on which to create the queue. A new exchange wwill be created if exchange does not exists
 * @param {*} routingKey The routing key for the exchange
 * @param {*} exchangeType The type of exhange, eg fanout|topic|direct
 * @param {*} options The options for que and exchange default {durable:true}
 */
function createQueue(server, exchange,name, routingKey, exchangeType, options = {
  durable: true
}) {
  return new Promise((resolve, reject) => {
    var channel = null;
    var connection = null;
    connectToServer(server)
      .then(conn => {
        connection = conn;
        return createChannel(connection);
      }).then(ch => {
        channel = ch;
        return connectToExchange(channel, exchange, exchangeType, options);
      }).then(ok=>{
        channel.assertQueue(name,options);
        
        channel.bindQueue(name,exchange,routingKey, options);
        setTimeout(()=>{connection.close()},500);
        return resolve(ok);
      }).catch(err=>{
        return reject(err);
      })
  });
}


module.exports = {
  connect,
  consumeMessages,
  createQueue,
  publishJSON,
  closeConnection
}