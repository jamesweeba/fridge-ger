let logger = require("./logger")
const amqp = require("amqplib/callback_api");



/**
 * Connects to the rabbitmq server
 * @param {*} server The ip/dns name for ther server. eg. 178.2.2.1
 */
function connectToServer(server) {
  return new Promise((resolve, reject) => {
    var serverUrl = "amqp://" + server;
    amqp.connect(serverUrl, (err, conn) => {
      if (err) {
        return reject(err);
      }
      logger.info("Connected to server, returning connection");
      resolve(conn);
    })
  })
}


/**
 * Create a channel on the abbitmq connection
 * @param {*} connection The connection param reveived from call to connectToServer
 */
function createChannel(connection) {

  return new Promise((resolve, reject) => {
    connection.createChannel((err, channel) => {
      if (err) {
        return reject(err);
      }

      return resolve(channel);

    });
  })

}


/**
 * Connect to an exchange
 * @param {*} channel The channe. for communication
 * @param {*} exchange The name of the exchange
 * @param {*} type The type of exchange eg. fanout|topic|direct
 * @param {*} options 
 */
function connectToExchange(channel, exchange, type, options) {
  return new Promise((resolve, reject) => {
    channel.checkExchange(exchange, (err, ok) => {
      if (err) {
        return reject({
          msg: "Invalid Exchange name!",
          err
        });
      }

      channel.assertExchange(exchange, type, options, (err, ok) => {
        if (err) {
          return reject(err);
        }

        return resolve(ok);
      });

    });

  })
}



/**
 * Process all messages in a queue
 * @param {*} channel  The chnnel to be used for communication with queue
 * @param {*} queue The name name of the queue
 * @param {*} callback  a callback function that process the messages in the queue callback(err,msg,done)
 * @param {*} maxConsumeSize The maximum number of messages that can be consumed at a time without acknowledgement. 
 */
function processQueue(channel, queue, callback, maxConsumeSize = 10) {

  logger.info("Connecting to queue " + queue, maxConsumeSize);


  if (!(isNaN(maxConsumeSize)) && maxConsumeSize > 0) {
    channel.prefetch(maxConsumeSize);
    logger.info("Channel Prefetch size set to " + maxConsumeSize);
  } else {
    logger.warn("Invalid Prefetch Size for channel. Invalid maxConsumeSize passed. Value should be a number>0. Instead value passed= " + maxConsumeSize);
  }


  channel.assertQueue(queue, {
    durable: true
  }, (err, ok) => {
    if (err) {
      logger.error("Error connecting to queue", queue, err);
      process.exit(1);
    }

    logger.info("Connected to Queue [ " + queue + " ] succesfully. Waiting to consume messages");

    channel.consume(queue, msg => {
      var content = msg.content;
      if (content) {
        var formattedMessage = content.toString();
        callback(null, formattedMessage, () => {
          channel.ack(msg);
        });
      }
    }, {
      noAck: false
    });

  });

}



module.exports = {
  connectToExchange,
  connectToServer,
  processQueue,
  connectToExchange,
  createChannel
}